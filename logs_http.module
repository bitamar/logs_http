<?php

/**
 * @file
 * Logs HTTP module.
 */

/**
 * Implements hook_menu().
 */
function logs_http_menu() {
  $items = array();

  $items['admin/config/services/logs-http-client'] = array(
    'type' => MENU_NORMAL_ITEM,
    'title' => 'Logs HTTP Client',
    'description' => 'Administer Logs Client settings.',
    'access arguments' => array('administer logs http client'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('logs_http_admin_settings'),
    'file' => 'logs_http.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_boot().
 *
 * Runs even for cached pages.
 */
function logs_http_boot() {
  set_exception_handler('_logs_http_exception_handler');
}

/**
 * Implements hook_exit().
 *
 * Log events after the response was sent to the browser.
 */
function logs_http_exit() {
  if (!$events = variable_get('logs_http_events', array())) {
    return;
  }

  $url = logs_http_get_http_url();

  // Send events to logs.
  foreach ($events as $event) {
    // Send data to Logs.
    $response = drupal_http_request($url, array(), 'POST', json_encode($event));
    // TODO: watchdog if response failed.
  }

  variable_del('logs_http_events');
}


/**
 * Provides custom PHP exception handling.
 *
 * Uncaught exceptions are those not enclosed in a try/catch block. They are
 * always fatal: the execution of the script will stop as soon as the exception
 * handler exits.
 *
 * @param $exception
 *   The exception object that was thrown.
 *
 * @see _drupal_exception_handler()
 */
function _logs_http_exception_handler($exception) {
  try {
    // Log the message to the watchdog and return an error page to the user.
    _drupal_log_error(_logs_http_decode_exception($exception), TRUE);
  }
  catch (Exception $exception2) {
    // Another uncaught exception was thrown while handling the first one.
    // If we are displaying errors, then do so with no possibility of a further uncaught exception being thrown.
    if (error_displayable()) {
      print '<h1>Additional uncaught exception thrown while handling exception.</h1>';
      print '<h2>Original</h2><p>' . _drupal_render_exception_safe($exception) . '</p>';
      print '<h2>Additional</h2><p>' . _drupal_render_exception_safe($exception2) . '</p><hr />';
    }
  }
}

/**
 * Decodes an exception and retrieves the correct caller.
 *
 * @param $exception
 *   The exception object that was thrown.
 *
 * @return array
 *   An error in the format expected by _drupal_log_error().
 *
 * @see _drupal_decode_exception()
 */
function _logs_http_decode_exception($exception) {
  $return = _drupal_decode_exception($exception);

  // We have to serialize and encode the array here to prevent a notice in
  // theme_dblog_message(). We will decode the string back in
  // logs_http_watchdog()
  $return['exception_trace'] = drupal_base64_encode(serialize($exception->getTrace()));
  return $return;

}

/**
 * Runs on shutdown to clean up and display developer information.
 *
 * devel_boot() registers this function as a shutdown function.
 */
function logs_http_shutdown() {

}

/**
 * Register an event in a static cache.
 *
 * To prevent multiple registration of the same error, we check that identical
 * events are not captured twice, thus reducing the final HTTP requests needed.
 *
 * @param array $log_entry
 *   The entry log as passed from hook_watchdog().
 */
function logs_http_register_event(array $log_entry) {
  $events = variable_get('logs_http_events', array());

  if (!logs_http_get_http_url()) {
    return;
  }
  $event = array(
    'timestamp' => $log_entry['timestamp'],
    'type' => $log_entry['type'],
    'ip' => $log_entry['ip'],
    'request_uri' => $log_entry['request_uri'],
    'referer' => $log_entry['referer'],
    'uid' => $log_entry['user']->uid,
    'link' => strip_tags($log_entry['link']),
    'message' => empty($log_entry['variables']) ? $log_entry['message'] : strtr($log_entry['message'], $log_entry['variables']),
    'severity' => $log_entry['severity'],
  );

  if (!empty($log_entry['variables']['exception_trace'])) {
    // @todo: We avoid unserializing as it seems to causes Logs to fail
    // to index event as JSON.
    $event['exception_trace'] = base64_decode($log_entry['variables']['exception_trace']);
  }

  if ($uuid = variable_get('logs_http_uuid', FALSE)) {
    $event['uuid'] = $uuid;
  }

  // Remove empty values, to prevent errors in the indexing of the JSON.
  $event = logs_http_array_remove_empty($event);

  // Prevent identical events.
  $event_clone = $event;
  unset($event_clone['timestamp']);
  $key = md5(serialize($event_clone));
  $events[$key] = $event;
  variable_set('logs_http_events', $events);
}

/**
 * Get the registered events from the static cache.
 *
 * @return array
 *   Array of events.
 */
function &logs_http_get_registered_events() {
  static $events = array();
  return $events;
}

/**
 * Implements hook_permission().
 */
function logs_http_permission() {
  $permissions = array();

  $permissions['administer logs http client'] = array(
    'title' => t('Administer Logs HTTP client'),
  );

  return $permissions;
}

/**
 * Implements hook_watchdog().
 *
 * Register watchdog events.
 */
function logs_http_watchdog(array $log_entry) {
  if ($log_entry['severity'] > variable_get('logs_http_severity_level', WATCHDOG_ERROR)) {
    // Severity level is above the ones we want to log.
    return;
  }

  logs_http_register_event($log_entry);
}

/**
 * Return the endpoint URL to POST data to.
 *
 * @return string
 *   Return the URL if exists, or NULL if disabled.
 */
function logs_http_get_http_url() {
  if (!variable_get('logs_http_enabled', TRUE) || !variable_get('logs_http_url', FALSE)) {
    // Don't register the event.
    return;
  }

  return variable_get('logs_http_url', FALSE);
}

/**
 * Deep array filter.
 *
 * Remove empty values.
 *
 * @param $haystack
 *   The variable to filter.
 *
 * @return mixed
 */
function logs_http_array_remove_empty($haystack) {
  foreach ($haystack as $key => $value) {
    if (is_array($value)) {
      $haystack[$key] = logs_http_array_remove_empty($haystack[$key]);
    }

    if (empty($haystack[$key])) {
      unset($haystack[$key]);
    }
  }

  return $haystack;
}

//// TODO: Everything below this line is here temporarily.

function _drupal_log_error($error, $fatal = FALSE) {
  // When running inside the testing framework, we relay the errors
  // to the tested site by the way of HTTP headers.
  $test_info = &$GLOBALS['drupal_test_info'];
  if (!empty($test_info['in_child_site']) && !headers_sent() && (!defined('SIMPLETEST_COLLECT_ERRORS') || SIMPLETEST_COLLECT_ERRORS)) {
    // $number does not use drupal_static as it should not be reset
    // as it uniquely identifies each PHP error.
    static $number = 0;
    $assertion = array(
      $error['!message'],
      $error['%type'],
      array(
        'function' => $error['%function'],
        'file' => $error['%file'],
        'line' => $error['%line'],
      ),
    );
    header('X-Drupal-Assertion-' . $number . ': ' . rawurlencode(serialize($assertion)));
    $number++;
  }

  watchdog('php', '%type: !message in %function (line %line of %file).', $error, $error['severity_level']);

}

function _drupal_decode_exception($exception) {
  $message = $exception->getMessage();

  $backtrace = $exception->getTrace();
  // Add the line throwing the exception to the backtrace.
  array_unshift($backtrace, array('line' => $exception->getLine(), 'file' => $exception->getFile()));

  // For PDOException errors, we try to return the initial caller,
  // skipping internal functions of the database layer.
  if ($exception instanceof PDOException) {
    // The first element in the stack is the call, the second element gives us the caller.
    // We skip calls that occurred in one of the classes of the database layer
    // or in one of its global functions.
    $db_functions = array('db_query', 'db_query_range');
    while (!empty($backtrace[1]) && ($caller = $backtrace[1]) && ((isset($caller['class']) && (strpos($caller['class'], 'Query') !== FALSE || strpos($caller['class'], 'Database') !== FALSE || strpos($caller['class'], 'PDO') !== FALSE)) || in_array($caller['function'], $db_functions))) {
      // We remove that call.
      array_shift($backtrace);
    }
    if (isset($exception->query_string, $exception->args)) {
      $message .= ": " . $exception->query_string . "; " . print_r($exception->args, TRUE);
    }
  }
  $caller = _drupal_get_last_caller($backtrace);

  return array(
    '%type' => get_class($exception),

    // The standard PHP exception handler considers that the exception message
    // is plain-text. We mimick this behavior here.
    '!message' => check_plain($message),
    '%function' => $caller['function'],
    '%file' => $caller['file'],
    '%line' => $caller['line'],
    'severity_level' => WATCHDOG_ERROR,
  );
}

function _drupal_get_last_caller($backtrace) {
  // Errors that occur inside PHP internal functions do not generate
  // information about file and line. Ignore black listed functions.
  $blacklist = array('debug', '_drupal_error_handler', '_drupal_exception_handler');
  while (($backtrace && !isset($backtrace[0]['line'])) || (isset($backtrace[1]['function']) && in_array($backtrace[1]['function'], $blacklist))) {
    array_shift($backtrace);
  }

  // The first trace is the call itself.
  // It gives us the line and the file of the last call.
  $call = $backtrace[0];

  // The second call give us the function where the call originated.
  if (isset($backtrace[1])) {
    if (isset($backtrace[1]['class'])) {
      $call['function'] = $backtrace[1]['class'] . $backtrace[1]['type'] . $backtrace[1]['function'] . '()';
    }
    else {
      $call['function'] = $backtrace[1]['function'] . '()';
    }
  }
  else {
    $call['function'] = 'main()';
  }
  return $call;
}
